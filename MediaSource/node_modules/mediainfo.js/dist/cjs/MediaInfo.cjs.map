{"version":3,"file":"MediaInfo.cjs","names":["FORMAT_CHOICES","exports","DEFAULT_OPTIONS","coverData","chunkSize","format","full","MediaInfo","constructor","mediainfoModule","options","mediainfoModuleInstance","analyzeData","getSize","readChunk","callback","undefined","Promise","resolve","reject","resultCb","result","err","offset","runReadDataLoop","fileSize","getChunk","readNextChunk","data","continueBuffer","finalize","dataValue","safeSize","Math","min","e","Error","then","catch","length","openBufferContinue","seekTo","openBufferContinueGotoGet","openBufferInit","openBufferFinalize","inform","parseResultJson","fileSizeValue","close","_this$mediainfoModule","destroy","size","open_buffer_continue","seekToLow","open_buffer_continue_goto_get_lower","seekToHigh","open_buffer_continue_goto_get_upper","open_buffer_finalize","open_buffer_init","resultString","intFields","INT_FIELDS","floatFields","FLOAT_FIELDS","JSON","parse","media","newMedia","track","Array","isArray","newTrack","key","val","Object","entries","includes","parseInt","parseFloat","push","_default","default"],"sourceRoot":"../../src","sources":["MediaInfo.ts"],"sourcesContent":["import type { MediaInfoFactoryOptions } from './MediaInfoFactory'\nimport type {\n  MediaInfoModule,\n  MediaInfoWasmInterface,\n  WasmConstructableFormatType,\n} from './MediaInfoModule'\nimport { FLOAT_FIELDS, INT_FIELDS, type MediaInfoType, type TrackType } from './MediaInfoType'\n\n/** Format of the result type */\ntype FormatType = 'object' | WasmConstructableFormatType\n\ntype MediaInfoOptions<TFormat extends FormatType> = Required<\n  Omit<MediaInfoFactoryOptions<TFormat>, 'locateFile'>\n>\n\ninterface GetSizeFunc {\n  (): Promise<number> | number\n}\n\ninterface ReadChunkFunc {\n  (size: number, offset: number): Promise<Uint8Array> | Uint8Array\n}\n\ninterface ResultMap {\n  object: MediaInfoType\n  JSON: string\n  XML: string\n  HTML: string\n  text: string\n}\n\nconst FORMAT_CHOICES = ['JSON', 'XML', 'HTML', 'text'] as const\n\nconst DEFAULT_OPTIONS = {\n  coverData: false,\n  chunkSize: 256 * 1024,\n  format: 'object',\n  full: false,\n} as const\n\ntype ResultCallback<TFormat extends FormatType> = (\n  result: ResultMap[TFormat] | null,\n  err?: unknown\n) => void\n\n/**\n * Convenience wrapper for MediaInfoLib WASM module.\n */\nclass MediaInfo<TFormat extends FormatType = typeof DEFAULT_OPTIONS.format> {\n  private readonly mediainfoModule: MediaInfoModule\n  private readonly mediainfoModuleInstance: MediaInfoWasmInterface\n  readonly options: MediaInfoOptions<TFormat>\n\n  /**\n   * Create an instance of MediaInfo. The constructor should not be called directly.\n   * Instead use {@link MediaInfoFactory}.\n   *\n   * @param mediainfoModule WASM module\n   * @param options User options\n   */\n  constructor(mediainfoModule: MediaInfoModule, options: MediaInfoOptions<TFormat>) {\n    this.mediainfoModule = mediainfoModule\n    this.options = options\n\n    // Instantiate\n    this.mediainfoModuleInstance = new mediainfoModule.MediaInfo(\n      options.format === 'object' ? 'JSON' : options.format,\n      options.coverData,\n      options.full\n    )\n  }\n\n  /**\n   * Convenience method for analyzing a buffer chunk by chunk.\n   *\n   * @param getSize Return total buffer size in bytes.\n   * @param readChunk Read chunk of data and return an {@link Uint8Array}.\n   */\n  analyzeData(getSize: GetSizeFunc, readChunk: ReadChunkFunc): Promise<ResultMap[TFormat]>\n\n  /**\n   * Convenience method for analyzing a buffer chunk by chunk.\n   *\n   * @param getSize Return total buffer size in bytes.\n   * @param readChunk Read chunk of data and return an {@link Uint8Array}.\n   * @param callback Function that is called once the processing is done\n   */\n  analyzeData(\n    getSize: GetSizeFunc,\n    readChunk: ReadChunkFunc,\n    callback: ResultCallback<TFormat>\n  ): void\n\n  analyzeData(\n    getSize: GetSizeFunc,\n    readChunk: ReadChunkFunc,\n    callback?: ResultCallback<TFormat>\n  ): Promise<ResultMap[TFormat] | null> | void {\n    // Support promise signature\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        const resultCb: ResultCallback<TFormat> = (result, err) =>\n          err ? reject(err) : resolve(result)\n        this.analyzeData(getSize, readChunk, resultCb)\n      })\n    }\n\n    let offset = 0\n    const runReadDataLoop = (fileSize: number) => {\n      const getChunk = () => {\n        const readNextChunk = (data: Uint8Array) => {\n          if (continueBuffer(data)) {\n            getChunk()\n          } else {\n            finalize()\n          }\n        }\n        let dataValue\n        try {\n          const safeSize = Math.min(\n            this.options.chunkSize ?? DEFAULT_OPTIONS.chunkSize,\n            fileSize - offset\n          )\n          dataValue = readChunk(safeSize, offset)\n        } catch (e) {\n          if (e instanceof Error) {\n            return callback('', e)\n          } else if (typeof e === 'string') {\n            return callback('', new Error(e))\n          }\n        }\n        if (dataValue instanceof Promise) {\n          dataValue.then(readNextChunk).catch((e) => callback('', e))\n        } else if (dataValue !== undefined) {\n          readNextChunk(dataValue)\n        }\n      }\n\n      const continueBuffer = (data: Uint8Array): boolean => {\n        if (data.length === 0 || this.openBufferContinue(data, data.length)) {\n          return false\n        }\n        const seekTo: number = this.openBufferContinueGotoGet()\n        if (seekTo === -1) {\n          offset += data.length\n        } else {\n          offset = seekTo\n          this.openBufferInit(fileSize, seekTo)\n        }\n        return true\n      }\n\n      const finalize = () => {\n        this.openBufferFinalize()\n        const result = this.inform()\n        if (this.options.format === 'object') {\n          callback(this.parseResultJson(result))\n        } else {\n          callback(result)\n        }\n      }\n\n      this.openBufferInit(fileSize, offset)\n      getChunk()\n    }\n\n    const fileSizeValue = getSize()\n    if (fileSizeValue instanceof Promise) {\n      fileSizeValue.then(runReadDataLoop).catch((err) => callback(null, err))\n    } else {\n      runReadDataLoop(fileSizeValue)\n    }\n  }\n\n  /**\n   * Close the MediaInfoLib WASM instance.\n   */\n  close(): void {\n    if (this.mediainfoModuleInstance) this.mediainfoModuleInstance.close()\n    if (this.mediainfoModule && typeof this.mediainfoModule?.destroy === 'function')\n      this.mediainfoModule.destroy(this.mediainfoModuleInstance)\n  }\n\n  /**\n   * Receive result data from the WASM instance.\n   *\n   * (This is a low-level MediaInfoLib function.)\n   *\n   * @returns Result data (format can be configured in options)\n   */\n  inform(): string {\n    return this.mediainfoModuleInstance.inform()\n  }\n\n  /**\n   * Send more data to the WASM instance.\n   *\n   * (This is a low-level MediaInfoLib function.)\n   *\n   * @param data Data buffer\n   * @param size Buffer size\n   * @returns Processing state: `0` (no bits set) = not finished, Bit `0` set = enough data read for providing information\n   */\n  openBufferContinue(data: Uint8Array, size: number): boolean {\n    // bit 3 set -> done\n    return !!(this.mediainfoModuleInstance.open_buffer_continue(data, size) & 0x08)\n  }\n\n  /**\n   * Retrieve seek position from WASM instance.\n   * The MediaInfoLib function `Open_Buffer_GoTo` returns an integer with 64 bit precision.\n   * It would be cut at 32 bit due to the JavaScript bindings. Here we transport the low and high\n   * parts separately and put them together.\n   *\n   * (This is a low-level MediaInfoLib function.)\n   *\n   * @returns Seek position (where MediaInfoLib wants go in the data buffer)\n   */\n  openBufferContinueGotoGet(): number {\n    // JS bindings don't support 64 bit int\n    // https://github.com/buzz/mediainfo.js/issues/11\n    let seekTo = -1\n    const seekToLow: number = this.mediainfoModuleInstance.open_buffer_continue_goto_get_lower()\n    const seekToHigh: number = this.mediainfoModuleInstance.open_buffer_continue_goto_get_upper()\n    if (seekToLow == -1 && seekToHigh == -1) {\n      seekTo = -1\n    } else if (seekToLow < 0) {\n      seekTo = seekToLow + 4294967296 + seekToHigh * 4294967296\n    } else {\n      seekTo = seekToLow + seekToHigh * 4294967296\n    }\n    return seekTo\n  }\n\n  /**\n   * Inform MediaInfoLib that no more data is being read.\n   */\n  openBufferFinalize(): void {\n    this.mediainfoModuleInstance.open_buffer_finalize()\n  }\n\n  /**\n   * Prepare MediaInfoLib to process a data buffer.\n   *\n   * @param size Expected buffer size\n   * @param offset Buffer offset\n   */\n  openBufferInit(size: number, offset: number): void {\n    this.mediainfoModuleInstance.open_buffer_init(size, offset)\n  }\n\n  /**\n   * Parse result JSON. Convert integer/float fields.\n   *\n   * @param result Serialized JSON from MediaInfo\n   * @returns Parsed JSON object\n   */\n  private parseResultJson(resultString: string): ResultMap[TFormat] {\n    type Writable<T> = { -readonly [P in keyof T]: T[P] }\n\n    const intFields = INT_FIELDS as ReadonlyArray<string>\n    const floatFields = FLOAT_FIELDS as ReadonlyArray<string>\n\n    // Parse JSON\n    const result = JSON.parse(resultString) as MediaInfoType\n\n    if (result.media) {\n      const newMedia = { ...result.media, track: [] as Writable<TrackType>[] }\n\n      if (result.media.track && Array.isArray(result.media.track)) {\n        for (const track of result.media.track) {\n          let newTrack: Writable<TrackType> = { '@type': track['@type'] }\n          for (const [key, val] of Object.entries(track) as [string, unknown][]) {\n            if (key === '@type') {\n              continue\n            }\n            if (typeof val === 'string' && intFields.includes(key)) {\n              newTrack = { ...newTrack, [key]: parseInt(val, 10) }\n            } else if (typeof val === 'string' && floatFields.includes(key)) {\n              newTrack = { ...newTrack, [key]: parseFloat(val) }\n            } else {\n              newTrack = { ...newTrack, [key]: val }\n            }\n          }\n          newMedia.track.push(newTrack)\n        }\n      }\n\n      return { ...result, media: newMedia } as ResultMap[TFormat]\n    }\n\n    return result as ResultMap[TFormat]\n  }\n}\n\nexport type { FormatType, GetSizeFunc, ReadChunkFunc, ResultMap }\nexport { DEFAULT_OPTIONS, FORMAT_CHOICES }\nexport default MediaInfo\n"],"mappings":"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"}